
                 Amiga Monitor 1.21 instructions
                 ===============================

  The monitor can be started both from CLI and from workbench. If you want
  to start the monitor from workbench, you must first make an icon for it.
  (starting the monitor from workbench is not recommended, because the
  programs that are run under the control of the monitor may require the
  CLI environment or else they may wait for workbench startup message
  forever...)

 Input line editing and command line history:
 --------------------------------------------
  You can edit the input lines by using the left/right cursor keys to move
  left and right, backspace to delete the character before the cursor and
  del to delete the character under the cursor. You can use the up/down
  cursor keys to get the old command lines (the monitor remembers 10 last
  command lines). Shift-cursor-up gets the last command and enters it
  automatically (you need not to press <CR>). In assembler mode you can
  press Ctrl-E to edit the assembler instruction currently stored in that
  address.

 Stopping the output:
 --------------------
  In most cases the output of the monitor can be suspended by pressing SPACE
  and continued by pressing SPACE again. To permanently stop the output,
  press Ctrl-C.

 Numbers:
 --------
  Default number base is hexadecimal but it can be changed with the ba-
  command (the argument of the ba-command is always decimal).
  the prefixes used to identify number bases are:
   '$'   hexadecimal
   '@'   octal
   '%'   binary
   '_'   decimal

  Numbers can also be entered as ASCII strings, for example:
   'FORM'  -->  hex 464f524d

  Note that '+' was the decimal prefix in previous versions. It is not
  any more.

 Expressions:
 ------------

 This version accepts expressions in most places where you need a number.
 The calculator ('?') command allows you to directly display
 values of expressions.

 The following operators are available:

 +   addition
 -   subtraction
 *   multiplication
 /   division (integer only, truncated)
 %%  modulo
 <<  left shift
 >>  right shift

 parenthesis can be used to group the operations in the expressions.

 '*'           represents the 'current address'.

 [reg_name]    represents the value of register 'reg_name'.

 All calculations are done in 32-bit integer arithmetic. No overflow
 checking is done.

 Functions:
 ----------

 The expression parser currently accepts the following built-in functions:

  hunk(n)  --  start address of nth hunk of currently loaded seglist
  hlen(n)  --  length of nth hunk of currently loaded seglist
  abs(x)   --  absolute value of a number  
  peek(a)  --  8-bit contents of a memory location
  peekw(a) --  16-bit contents of a memory location
  peekl(a) --  32-bit contents of a memory location
  avail(x) --  call AvailMem() with the argument x. for example
		avail(0) returns total available memory,
		avail(2) returns available chip memory
		avail($20000) return largest available block.

 Variables:
 ----------

 in addition to numbers and functions, variables can be used in expressions
 if they are previously defined. Variables are defined with the set-command.
 All variable values are 32-bit integers. Variable names can contain
 alphanumeric characters and underscores ('_'), but they cannot begin
 with a number.

 Strings:
 --------
  Strings are used in the fill command, the hunt command, the modify memory
  command and the assembler directive dc.b .
  Strings are series of bytes, represented by numbers or ASCII-characters
  in single quotes or both together separated by commas.
  Note: the single quote itself may be included in a quoted string if it
  is duplicated.
   examples:
    'this is a string'
    12,34,56
    ''''  -- this means one single quote
    'both',$0A,'text',10,'and','numbers'


New features and bug fixes in version 1.21
------------------------------------------
 - variables are now case-insensitive

New features and bug fixes in version 1.20
------------------------------------------
 - added the '[register]'-syntax in the expression parser

New features and bug fixes in version 1.18 & 1.19
-------------------------------------------------
 - disassembler now uses new routines. this makes the monitor
   executable little smaller than 1.17

New features and bug fixes in version 1.16 & 1.17
-------------------------------------------------
 - monitor is now re-entrant and can be made resident

 - transfer no longer crashes if you transfer from location zero

 - default base is again hexadecimal

New features and bug fixes in version 1.14 & 1.15
-------------------------------------------------
 - some minor bug fixes in assembler
   (move sp,usp or exg Rx,sp did not work)

 - 'memory info'-command

 - underscores are allowed in variable names

 - variable list is kept in alphabetical order

New features in version 1.11 & 1.12:
------------------------------------
 - expressions can now be used instead of numbers. also included
   calculator-command.

 - variables can be used in expressions.

 - user-defineable default number base, default is now decimal.

 - hunt-command no longer finds anything in the monitor code/data areas

 - show seglist now displays hunk numbers

 - chip memory allocation syntax has been changed.

New features and bug fixes in version 1.08:
-------------------------------------------
 - The disassembler and assembler handle exg Dn,An correctly
   (previously the data and address register numbers were reversed)

 - The disassembler no more displays any invalid codes as valid
   instructions (On the 68000 processor, of course. The monitor does
   not currently support 68010/68020 extra instructions).

 - The pc-relative indexed addressing mode now works with the assembler.

 - Some little bugs were fixed in the assembler.
    + And/or-instructions work with a pc-relative source operand. 
    + cmpm works with all sizes
    + most(if not all...) of the bugs that caused the assembler to
      assembler invalid instructions have been fixed.

 - 'sp' can be used instead of 'a7' in the assembler and the disassmbler
   displays a7 as 'sp'.

 - The assembler now unserstands blo/bhs, slo/shs and dblo/sbhs
   and assembles them as bcs/bcc, scs/scc and dbcs/dbcc

 - The disassembler displays address-register relative offsets and short
   absolute addresses as signed numbers.

 - The monitor works now better with 60-column mode.

 - Disk read/write commands can be used with non-chip memory

 - Play digisound command has an optional parameter to specify
   how many times the sample is played.

 - A new command has been added to specify a command line for programs
   executed under the control of the monitor.

 - Breakpoints work even if you jump into the code at to breakpoint.
   The breakpoint does not activate until the instruction at the break
   position is executed, so you don't get immediately interrupted.
   (internally the monitor uses the trace-exception to skip the breakpoint
   at the first time...)

 - the monitor works ok with 68010/68020 processors. previous versions
   left sometimes extra data in supervisor stack. this was fixed in
   version 1.08.


Special Note:
-------------
 There is a problem with the walk (trace) command and several instructions
 that cause processor exceptions. These instructions are chk, trap #n,
 trapv and divu/divs (with divisions by zero). If you try to trace these
 instructions, a trace-exception occurs in supervisor-mode, out of the
 monitors control and you get a guru meditation alert with number 00000009.
 This problem was with the earlier monitor versions as well. In the new
 version it can also also occur if you jump to the code at a breakpoint
 address, as the monitor internally traces over the breakpoint.

 Included with the monitor is a program called patchtrace that changes
 directly the processor hardware trace-exception vector to point a new
 routine that removes the trap-trace problem.


 The following commands are available in the monitor:
 ----------------------------------------------------

h or the HELP key on the keyboard
 displays a help screen.

i -- info
 displays info-message

o -- redirect output
 usage:
  o name -- redirects monitor output to file or device 'name'
  o      -- returns to normal, output comes to the monitor window
 for example, to send the output to printer use 'o PRT:'.

? [expr]  --  calculator
  displays the value of the expression in hex, decimal, octal and binary.
  If the number is negative, displays it as signed and unsigned.

set [var=expr] -- set/show variables
  the set-command without parameters displays the values of all currently
  defined variables. the form 'set var=expr' sets the value of 'var' to
  the value of the expression.

cv -- clear all variables
  asks if you really want to do it, answer 'y' to clear them.

ba [num]  --  set/show current number base
  ba without parameters displays the current number base. ba [num] sets
  the base to [num] which is always decimal. this is the default base
  used in number input if no base prefix is specified. initially it is 16
  (hexadecimal).

mi [addr] -- display information about memory locations
  the mi-command tells you if the address 'addr' is in the system memory
  list, is it allocated or not and is it inside any of the hunks
  of the currently loaded segment.

m -- display memory in hex and ASCII
 usage:
  m                   -- display 20 lines from current address
  m <addr>            -- display 20 lines from <addr>
  m <addr> <end-addr> -- display from <addr> to <end-addr>

: -- modify memory
 usage:
  : <addr> <string>
  puts the <string> in memory at <addr>
  this can also be done with the command 'a <addr> dc.b <string>'

f -- fill memory with a byte or a string of bytes
 usage:
  f <start-addr> <end-addr> <byte>   ;fills with <byte>
  f <start-addr> <end-addr> <string> ;fills with the string
 example:
  f $60000 $601FF $4E,$71 fills from $60000 to $601FF with NOP-instruction

t -- transfer (move) memory
 usage:
  t <start-addr> <end-addr> <destination-addr>
 the command works correctly even if the source and destination memory
 blocks overlap. (if destination is at a higher address than source,
  the block is moved backwards, starting at the end)

h -- hunt (find) string in memory
 usage:
  h <start-addr> <end-addr> <string>
  displays all addresses in the range <start-addr>..<end-addr>
  where the <string> is found.

c -- compare memory
 usage:
  c <start-addr> <end-addr> <string>
  displays all addresses in the range <start-addr>..<end-addr>
  where is corresponding byte in the destination block is different from
  the source.

a -- assemble
 usage:
  a         : assemble to the current address
  a <addr>  : assemble to <addr>
  a <addr> <instruction> : assemble <instruction> at <addr>
  After assembling an instruction the monitor prompts with the address of
  the location following the instruction just assembled and waits a new
  instruction to be entered. To exit this mode, simply press <CR> without
  entering an instruction. To edit an existing instruction, press Ctrl-E when
  the monitor is waiting an assembler instruction.
   The assembler understands all the normal 68000 instructions and also
  the 'pseudo-instructions' dc.b, dc.w and dc.l, which can be used to
  directly put data in memory.

 Some notes about using the assembler:
 -------------------------------------
   When entering assembler instructions which have an implicit size, no
   size specifier is allowed in the monitor assembler. These instructions
   are for example btst, bchg, bclr, btst, lea, move to/from sr/ccr/usp,
   andi/ori/eori #data,sr/ccr Scc (set according to condition),
   abcd/sbcd/nbcd and shifts with memory operands.

   Instructions that can have different sizes must have the size specifier,
   there is no 'default size' (normal assemblers use a default size of word.
   the omission of default size is intentional, because it is so easy to
   forget the size specifier when you really don't mean the size to be word).

   Branch instructions with no size specifier or the .l-specifier assemble
   to normal (16-bit offset) branches, if given the .s-size specifier they
   assemble to the short form (8-bit offset). The dbxx-(decrement and branch)
   -instructions allow no size specifier.

   The assembler converts add/sub/and/or/eor with immediate data source
   automatically to adda/addi/subi/andi/eori. It does not convert move or
   add/sub to the quick form nor does it convert branches automatically to
   the short form. You must specify those yourself (so you must use the
   moveq/addq/subq- instructions or specify the size .s to branches
   as noted above). Also cmp-memory instruction must be entered as cmpm,
   the assembler does not convert cmp (an)+,(an)+ to cmpm.

   The above conversion rules do not apply to andi/ori/eori with status
   register or condition code register. In these cases you must enter the
   instruction as andi/ori/eori (don't leave the 'i' out). Also, you
   can't enter any size specifier in this case.


d -- disassemble
 usage:
  d                   -- disassemble 20 lines from current address
  d <addr>            -- disassemble 20 lines from <addr>
  d <addr> <end-addr> -- disassemble from <addr> to <end-addr>

r -- show or change registers
 usage:
  r        -- displays all registers
  r <reg>=<number> or
  r <reg> <number> -- puts the value <number> into <reg>
   examples:
    r D0=0
    r A5 $60000

b -- set breakpoints
 usage:
  b <addr> -- sets a breakpoint to <addr>
   Breakpoints are implemented by putting an illegal opcode ($4AFC) in the
  breakpoint locations when a G or J command is given. After returning to
  the monitor the original contents of the breakpoints are restored. This
  means that you can not put breakpoints to ROM (but you can trace ROM code).

br -- remove breakpoints
 usage:
  br <addr> -- removes the breakpoint at <addr>
  br all    -- removes all breakpoints

bl -- list breakpoints
 usage:
  bl -- display a list of all breakpoints

g [addr] -- go (execute machine code)

j [addr] -- jump to subroutine

w [addr] -- walk (single step trace)
 (this does not activate breakpoints)

 the g, j and w-commands use the current program counter value
 (displayed with the r-command) if you don't give them an address.

note: there is no easy way to run BCPL programs (CLI commands) or other
programs that use the internal BCPL library from the monitor.

@ -- enter command line
 usage:
  @ [command line]. If you don't specify a command line (enter only @<cr>)
  then the monitor will prompt for command line. the command line will
  be put in a special memory area and the register a0 will contain pointer
  to the string and d0 will contain length of the string (with a linefeed
  appended to end of it).
  The purpose of this command is to specify a command line for the program
  that you are running from the monitor.

l -- load segment
 usage:
  l <name> -- loads the executable file <name> in memory and displays
  the starting address of the first hunk, also sets PC to this address.
  only one segment can be loaded at the same time. Before loading a new
  segment you must unload the old segment with the u-command. To display
  the starting & ending addresses of all the hunks in the file, use the
  sl-command.

u -- unload segment
 usage:
  u  -- unload the current segments (frees the memory of that segment)

sl -- segment list
 usage:
  sl -- displays the starting & ending addresses and length of each hunk
  of the currently loaded file.

( -- allocate memory
 usage:
  ( <length>        -- allocate <length> bytes any type of memory
  ( <length> C      -- allocate <length> bytes of chip memory
  Displays the start & end addresses of the allocated memory block.

& -- allocate absolute memory location
 usage:
  & <addr> <length> -- allocate <length> bytes at <addr>

) -- free memory
 usage:
  ) <addr> -- frees the memory block starting at <addr>
  ) all    -- frees all the memory allocated with the (- and &-commands

sm -- show allocated memory
 usage:
  sm -- display all memory blocks allocated with the (- and &-commands

[  -- read file
 usage:
  [ <addr> <name> -- reads the file <name> to memory starting at <addr>

]  -- write file
 usage:
  ] <addr> <length> <name> -- creates a file named <name> and writes <length>
 bytes of memory starting at <addr> to the file.

<  -- read disk sectors
 usage:
  < <addr> <drive> <start-sector> <number-of-sectors>
 Reads <number-of-sectors> sectors from the disk in unit <drive> to memory
 starting at <addr>. <drive> is a number between 0..3,
 corresponding the DOS devices DF0: -- DF3:

 the read destination address does not need to be in chip memory.

>  -- write disk sectors
 usage:
  > <addr> <drive> <start-sector> <number-of-sectors>
 Writes <number-of-sectors> sectors to the disk in unit <drive> from memory
 starting at <addr>. <drive> is a number between 0..3,
 corresponding the DOS devices DF0: -- DF3:

 the write source address does not need to be in chip memory.

=  -- corrects a disk block checksum
 usage:
  = <addr> -- if there is a DOS-format disk block read into memory at <addr>,
 calculates the correct checksum for the block and stores it in the block.
 Displays old and new checksums. This command is useful if use use the
 monitor as a disk editor.

#  -- corrects bootblock checksum
 usage:
  # <addr> -- if there is a disk bootblock (2 disk blocks, 1024 bytes) read
 into memory at <addr>, calculates a new checksum for the bootblock and stores
 it in the bootblock. Displays old and new checksums.

!  -- play digisound
 usage:
  ! <addr> <length> <period> [<count>]
 Plays sound <length> bytes starting at <addr> and using sampling period
 <period>. the sound repeats <count> times or until you stop it by
 pressing Ctrl-C. <addr> must be in CHIP memory!.

cls -- clears the monitor window

del <filename> -- deletes a file
cd  <dirname>  -- sets the current directory

dir [<name>]   -- displays the directory
  if you don't specify the name, then current directory
  will be displayed.

\ -- new CLI
  Opens a new CLI window. This CLI is a separate process, so you can continue
  to use the monitor when the CLI window is there. Also the CLI window does
  not close automatically when you exit the monitor. You must close it with
  the CLI command EndCLI. In fact the monitor uses the NewCLI command
  to open the new CLI window.

x -- exit
 frees all memory allocated by the monitor, closes redirection file (if open)
 and exits the monitor.


version 1.21 of the monitor (and this document) --> 1990-01-06

  Timo Rossi
  Kellankoski			internet e-mail:
  44300 Konnevesi		trossi@jyu.fi
  FINLAND

